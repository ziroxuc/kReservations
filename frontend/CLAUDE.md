# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a **Kafè Restaurant Reservation System Frontend** - an Angular 18 SPA with real-time WebSocket integration for restaurant table reservations. The app uses modern Angular features including **Signals for state management**, standalone components, and the new control flow syntax (@if, @for).

Key characteristics:
- **Real-time availability**: WebSocket updates when slots become available/unavailable
- **Pessimistic locking**: 5-minute temporary locks prevent double bookings
- **Multi-step wizard**: 4-step guided reservation flow with validation
- **Signal-based state**: All state managed through Angular Signals (no NgRx/Akita)

## Common Commands

### Development
```bash
# Start dev server (http://localhost:4200)
npm start

# Build for development
npm run build

# Build for production
npm run build:prod

# Run linter
npm run lint
```

### Testing
```bash
# Run all tests (Karma + Jasmine)
npm test

# Run tests with coverage report
npm test -- --code-coverage

# Run E2E tests (interactive mode - best for development)
npm run e2e:open

# Run E2E tests (headless - CI mode)
npm run e2e

# Run E2E in specific browser
npm run e2e:chrome
npm run e2e:firefox
```

### Docker
```bash
# Build production image
docker build -t kafe-frontend .

# Run container
docker run -p 80:80 kafe-frontend
```

## Architecture Overview

### State Management Pattern
This app uses **Angular Signals exclusively** for state management (no RxJS stores). The single source of truth is `ReservationStateService` at `src/app/features/reservation/services/reservation-state.service.ts`.

Key pattern:
```typescript
// Private writable signals
private _currentStep = signal<number>(1);

// Public readonly signals
readonly currentStep = this._currentStep.asReadonly();

// Computed signals (auto-update when dependencies change)
readonly isLockActive = computed(() => {
  const lock = this._lockInfo();
  return lock && new Date(lock.expiresAt) > new Date();
});

// Actions to update state
updateReservationData(data: Partial<ReservationData>): void {
  this._reservationData.update(current => ({ ...current, ...data }));
}
```

### Component Architecture
**Smart/Presentational Pattern**:
- **Pages** (`features/reservation/pages/`): Container components with business logic, inject services
- **Components** (`features/reservation/components/`): Presentational components, receive data via @Input, emit events via @Output
- **Shared** (`shared/components/`): Reusable UI components (loader, error-message, progress-indicator, lock-timer)

All components are **standalone** (no NgModules). Use `inject()` instead of constructor DI.

### WebSocket Integration
The `WebSocketService` (src/app/core/services/websocket.service.ts) connects to `/reservations` namespace and handles:
- **Client emits**: `subscribe:availability` when user selects a date
- **Server emits**: `availability:changed` (slot status changed), `lock:expired` (user's lock expired)

WebSocket is initialized in `AppComponent` on startup and remains connected throughout the session.

### Reservation Flow & Locking
1. **Steps 1-3**: User fills out date/time, guest info, party details (no lock yet)
2. **Step 4**: User selects region/preferences → **lock acquired** (5 min timeout)
3. **Review page**: Protected by `reservationLockGuard` - redirects if no active lock
4. **Confirmation**: Lock released after successful reservation

Lock info stored in `ReservationStateService._lockInfo` signal. Lock expiration checked via computed signal `isLockActive()`.

## Key Business Rules

### Region Constraints
Regions have capacity and restriction rules defined in backend that must be respected:

| Region | Max Capacity | Children Allowed | Smoking |
|--------|--------------|------------------|---------|
| Main Hall | 12 | Yes | No |
| Bar | 4 | No | No |
| Riverside | 8 | Yes | No |
| Riverside Smoking | 6 | No | Yes |

The `RegionSelectorComponent` automatically disables regions that don't match the user's party size, children count, and smoking preferences.

### Validation Rules
- **Date range**: July 24-31, 2025 (hardcoded business requirement)
- **Time slots**: 18:00-22:00 in 30-minute intervals
- **Party size**: 1-12 guests
- **Children count**: Must not exceed party size
- **Region selection**: Filtered based on party size, children presence, and smoking preference

### Session Management
Each user session has a unique `sessionId` generated by `ReservationStateService.generateSessionId()`. This session ID is:
- Used for lock acquisition and release
- Sent with all reservation API calls
- Regenerated on state reset

## Code Style Conventions

### TypeScript Strict Mode
TypeScript strict mode is enabled (`tsconfig.json`). All code must:
- Have explicit types for function parameters and return values
- Avoid `any` types
- Handle null/undefined cases

### Angular 18 Patterns
**Always use these modern patterns:**
- Standalone components (`standalone: true`)
- Functional DI with `inject()` instead of constructor injection
- New control flow: `@if`, `@for`, `@switch` instead of `*ngIf`, `*ngFor`, `*ngSwitch`
- Signals for reactive state instead of BehaviorSubject/RxJS state

**Example component structure:**
```typescript
@Component({
  selector: 'app-example',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './example.component.html',
  styleUrl: './example.component.scss'
})
export class ExampleComponent {
  private stateService = inject(ReservationStateService);
  private router = inject(Router);

  // Use signals for local state
  protected selectedOption = signal<string | null>(null);

  // Effects must be in constructor (injection context)
  constructor() {
    effect(() => {
      // If this effect calls methods that update signals, add allowSignalWrites
      const value = this.selectedOption();
      if (value) {
        this.doSomething(value);
      }
    }, { allowSignalWrites: true });
  }
}
```

### Service Layer Organization
- **Core services** (`core/services/`): App-wide singletons (API, WebSocket, Notification)
- **Feature services** (`features/reservation/services/`): Feature-specific services (ReservationState, ReservationApi, Availability)
- All services use `providedIn: 'root'` for singleton behavior

### SCSS Styling
- Global variables and mixins in `src/styles/` (`_variables.scss`, `_mixins.scss`)
- Component styles use SCSS syntax with component-scoped styles
- Mobile-first responsive design approach

## Testing Strategy

### Unit Test Structure
Tests use Jasmine + Karma. Key patterns:
- Service tests focus on state management logic and computed signals
- Component tests verify user interactions and template bindings
- Guards tests ensure navigation protection works correctly

**Example test for signals:**
```typescript
it('should compute isLockActive correctly', () => {
  service.setLockInfo({
    lockId: 'test',
    sessionId: 'session-1',
    expiresAt: new Date(Date.now() + 60000).toISOString() // 1 min future
  });
  expect(service.isLockActive()).toBe(true);
});
```

### E2E Tests with Cypress
The project has 63+ E2E tests organized into test suites. Tests use **custom commands** defined in `cypress/support/commands.ts` to avoid code duplication.

**Custom commands available:**
- `cy.completeStep1(date, timeSlot)` - Fill out date/time selection
- `cy.completeStep2(name, email, phone)` - Fill out guest info
- `cy.completeStep3(partySize, childrenCount, hasBirthday, birthdayName?)` - Fill out party details
- `cy.completeStep4(regionName, smokingRequest)` - Select region and preferences
- `cy.getByCy(selector)` - Get element by data-cy attribute

**Example usage:**
```typescript
it('should complete full reservation flow', () => {
  cy.visit('/');
  cy.completeStep1('2025-07-24', '19:00');
  cy.completeStep2('John Doe', 'john@example.com', '+1234567890');
  cy.completeStep3(4, 0, false);
  cy.completeStep4('Main Hall', false);

  // Now on review page with active lock
  cy.url().should('include', '/review');
  cy.contains('Confirm Reservation').click();
  cy.url().should('include', '/confirmation');
});
```

### Running Tests
- Default: `npm test` (opens browser, watches for changes)
- CI mode: `npm test -- --browsers=ChromeHeadless --watch=false`
- Coverage: `npm test -- --code-coverage` (generates report in `coverage/frontend/`)

## Environment Configuration

### Local Development
Edit `src/environments/environment.ts`:
```typescript
export const environment = {
  production: false,
  apiUrl: 'http://localhost:3000/api', // Backend API URL (HTTP requests)
  wsUrl: 'http://localhost:3000'        // WebSocket URL (without /api)
};
```

### Production
Edit `src/environments/environment.prod.ts`:
```typescript
export const environment = {
  production: true,
  apiUrl: 'https://api.your-domain.com/api',
  wsUrl: 'https://api.your-domain.com'
};
```

**Important**: The `wsUrl` must NOT include `/api` because WebSocket connects to the namespace path directly (e.g., `ws://localhost:3000/reservations`).

The environment is injected in services via:
```typescript
import { environment } from '../../../environments/environment';
```

## Important Files

### State & Services
- `src/app/features/reservation/services/reservation-state.service.ts` - **Single source of truth** for all reservation state
- `src/app/core/services/websocket.service.ts` - WebSocket connection and event handling
- `src/app/features/reservation/services/availability.service.ts` - Availability fetching and caching

### Guards (Route Protection)
- `src/app/core/guards/step-navigation.guard.ts` - Prevents users from skipping steps by typing URLs manually. Validates that required data from previous steps exists before allowing navigation.
- `src/app/core/guards/reservation-lock.guard.ts` - Protects the review page, ensuring user has an active lock before viewing.

Both guards are **functional guards** (`CanActivateFn`) using Angular 18's modern approach with `inject()`.

### Models
- `src/app/core/models/reservation.model.ts` - ReservationData, LockInfo interfaces
- `src/app/core/models/availability.model.ts` - TimeSlot, Alternative interfaces
- `src/app/core/models/enums.ts` - Region, ReservationStatus enums

### Routing & Guards
- `src/app/app.routes.ts` - Route definitions with guard configuration
- Routes are protected by guards to ensure data integrity and prevent unauthorized access

### Configuration
- `src/app/app.config.ts` - Application providers (HTTP client with interceptors, router)
- `angular.json` - Angular CLI build configuration
- `tsconfig.json` - TypeScript strict mode settings
- `cypress.config.ts` - E2E test configuration with extended timeouts

## Docker Deployment

The Dockerfile uses a **multi-stage build**:
1. **Stage 1 (builder)**: Installs dependencies and builds the Angular app with `npm run build`
2. **Stage 2 (nginx)**: Copies built artifacts to nginx and serves on port 80

Build output path: `dist/frontend/browser/` (defined in `angular.json`)

Nginx configuration (`nginx.conf`) handles SPA routing by redirecting all 404s to index.html.

## Common Patterns & Anti-Patterns

### ✅ DO
- Use Signals for all reactive state
- Use `computed()` for derived values instead of manually updating multiple signals
- Return `asReadonly()` from services to prevent external mutation
- Use `inject()` in component/service constructors
- Subscribe to WebSocket events in services, not components
- Clean up subscriptions in `ngOnDestroy` when using RxJS (WebSocket events)
- Put `effect()` calls inside the constructor, NOT in `ngOnInit()` (effect requires injection context)
- Use `{ allowSignalWrites: true }` in `effect()` if you need to call methods that update signals (e.g., loading states)

### ❌ DON'T
- Don't use `BehaviorSubject` for state when Signals will work
- Don't mutate signal values directly - use `.set()` or `.update()`
- Don't call signal setters from templates (actions should be in component class)
- Don't use constructor injection - use `inject()` function
- Don't forget to release locks when user navigates away
- Don't make components stateful when they should be presentational

## Step Navigation Guard Logic

The `stepNavigationGuard` implements sequential validation:

```typescript
// Step 1: Always accessible (entry point)

// Step 2: Requires date + timeSlot from Step 1
if (!data.date || !data.timeSlot) → redirect to step 1

// Step 3: Requires all Step 2 data (customerName, email, phone)
if (!data.customerName || !data.email || !data.phone) → redirect to step 2

// Step 4: Requires all Step 3 data (partySize > 0)
if (data.partySize === undefined || data.partySize <= 0) → redirect to step 3
```

This prevents users from accessing `/reservation/step/4` directly without completing previous steps, ensuring data integrity throughout the flow.

## WebSocket Connection Pattern

```typescript
// Initialize in AppComponent.ngOnInit()
this.wsService.connect();

// Subscribe in service constructors
this.wsService.onAvailabilityChanged().subscribe(data => {
  // Refresh availability when other users book
});

this.wsService.onLockExpired().subscribe(data => {
  if (data.sessionId === this.stateService.sessionId()) {
    // Redirect user if their lock expired
    this.router.navigate(['/reservation/step/1']);
  }
});
```

## Lock Timer Implementation

The lock timer in `LockTimerComponent` updates every second using `setInterval` and displays countdown in MM:SS format:

```typescript
// Update time remaining every second
this.timerInterval = setInterval(() => {
  this.updateTimeRemaining();
}, 1000);

// Computed signal for formatted display
protected formattedTime = computed(() => {
  const ms = this.timeRemaining();
  const totalSeconds = Math.floor(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes}:${seconds.toString().padStart(2, '0')}`;
});

// Show warning when < 1 minute
protected isWarning = computed(() => this.timeRemaining() < 60000);
```

Always clean up the interval in `ngOnDestroy()` to prevent memory leaks.
